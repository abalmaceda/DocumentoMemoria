
\section{Aplicaciones \webINT}\label{cap:estadoArte:section:web_app}

\begin{itemize}
	\item
		\textbf{\singlePageAppINT} se distinguen por su habilidad de \redrawCPT cualquier parte de la \uiSiglaAS sin requerir intervención del \serverAS. Esto se logra separando la \dataPC de la presentación de \dataPC teniendo un \modelLayerAS que \handleAS la \dataPC y una \viewsLayerAS que lea desde los \modelsAS.
		%Single page apps are distinguished by their ability to redraw any part of the UI without requiring a server roundtrip to retrieve HTML. This is achieved by separating the data from the presentation of data by having a model layer that handles data and a view layer that reads from the models.
	\item
		\textbf{Aplicaciones \isomorphicAS \javaScriptNAME} son aplicaciones escritas en \javaScriptNAME que pueden correr tanto en el \clientAS como en el \serverAS. Por consecuencia, es posible escribir código y ejecutarlo en el \serverAS para \renderCPT páginas estáticas y en el \clientAS para permitir interacciones rápidas.
		%Isomorphic JavaScript applications are applications written in JavaScript that can run both on the client and on the server. Because of this, you can write the code once and then execute it on the server to render static pages and on the client to allow for fast interactions. So, this approach takes the best of the two worlds and lets you avoid the two issues described before.
\end{itemize}

%\section{El futuro de las aplicaciones \webINT}
%
%Cuanto más organizaciones se sientan cómodas \runningCPT \nodejsNAME en \productionPC, es inevitable que cada vez más y más aplicaciones \webINT comiencen a compartir código entre el \clientAS y el \serverAS. Es importante recordar que \isomorphicAS \javaScriptNAME es una gama - puede empezar solo compartiendo \templatesAS, progresando hasta convertirse
%As more organizations get comfortable running Node.js in production, it’s inevitable that more and more web apps will begin to share code between their client and server code. It’s important to remember that isomorphic JavaScript is a spectrum — it can start with just sharing templates, progress to be an entire application’s view layer, all the way to the majority of the app’s business logic. Exactly what and how JavaScript code is shared between environments depends entirely on the application being built and its unique set of constraints.

%Nicholas C. Zakas has a nice description of how he envisions apps will begin to pull their UI layer down to the server from the client, enabling performance and maintainability optimizations. An app doesn’t have to rip out its backend and replace it with Node.js to use isomorphic JavaScript, essentially throwing out the baby with the bathwater. Instead, by creating sensible APIs and RESTful resources, the traditional backend can live alongside the Node.js layer.